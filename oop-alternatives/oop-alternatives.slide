I Object!
Alternatives to the popular Object-Oriented Programming paradigm
25 Jun 2015

Nathan Moos
moosnat@umich.edu
https://moosingin3space.github.io
@moosingin3space

* Programming problems, in general

- Shared, mutable state
- End of the Moore's Law "free lunch", but added complexity involved in parallelism
- Managing complexity
- Too much code

* What is OOP good for?

- Data hiding or encapsulation
- Polymorphism or the reuse of functions in different contexts
- Abstraction
- Maintenance

* What is OOP associated with?

- Static typing
- User Interfaces and Game Engines

* Encapsulation

OOP: Private variables and functions

.code private-data-example.java

* Defeated by

Threading! There is no protection from unanticpated re-ordering of updates
due to non-deterministic multicore thread execution!

.code threading-breaks-encapsulation.java

* Encapsulation

Alternative: Modules and pure functions

.code modules-example.go

Note that there's no mutable state at the module level.

* Polymorphism

OOP: Classes

.code classes-example.java

* An example

A sell price is a price. So is a buy price. A price is a number. This suggests
inheritance. Can I model this with sub-classing?

* Defeated by

Inflexibility and high ceremony.

.code classes-are-inflexible.java

* Polymorphism

Alternative: Dynamic Typing

.code dynamic-typing.js

Very low-ceremony, but requires a lot of testing to verify that it works!
We can do better...

* Polymorphism

Alternative: Algebraic Data Types

.code typeclasses-example.hs

Less ceremony and slightly more malleable, but retains the compiler's ability
to check for bugs.

* Polymorphism

Alternative: Multiple dispatch

.code multimethods-example.clj

Powerful way to switch on type or another attribute.

* Polymorphism

Alternative: Separation of data and functions, structural sub-typing

.code interfaces-example.go

Low-ceremony and malleable.

* Abstraction

Alternative: FP concepts

.code map-reduce-example.hs

Notice how maps and folds can be used to perform all of these similar
operations.

* Maintenance

Complexity damns you twice: it takes more effort to understand complex code,
and it needs more maintenance.

OOP tends to have high ceremony: see classes, dependency injection, etc.

* Parallellism

OOP: Locking

.code locking-example.java

Not only is this an increase in ceremony, but it also performs badly.

* Parallellism

Alternative: Software-transactional memory

.code stm-example.clj

STM enables global state to be modified safely.

* Notes on Typing

* User Interface and Game Engines

Alan Kay, inventor of OOP, believed it would lay the foundation for an elegant
user interface.

OOP user interfaces require components to maintain state, _independent_ of the
application state. Usually, this is unnecessary duplication

In FRP, components are just functions that take all data needed to generate the
representation. No state outside of the app state.

* What if we don't have a choice?

* Web frontend: JavaScript

- Module pattern (Browserify, Require.js)
- Dynamic polymorphism
- Underscore or Lodash
- Promises
- FRP (React.js, Mercury)

* Web frontend: compile-to-JavaScript

- TypeScript: structural sub-typing with its `interface` types
- PureScript: Haskell written in JavaScript
- ClojureScript: Clojure compiled to JavaScript
- Elm: Haskell-style code, FRP, complete abstraction over DOM
- GHCJS/Haste: Haskell compiled to JavaScript

* Android frontend

- *Always* write user interfaces in Java, unless it's a game!
- Java 8/Retrolambda
- RxJava
- Scaloid
- Clojure-Android
- Haskell-JNI

* iOS frontend

- Swift
- RxSwift
- Functional operators in Swift

* Always applicable

- Prefer functions to classes
- Classes (or namespaces) as modules
- Immutability
- Document side effects _clearly_
- Procedural code with a module system

* Why do we care?

- We want code that we can quickly iterate on
- We want code that is clear in its intent
- We want code that doesn't punish us for taking breaks
